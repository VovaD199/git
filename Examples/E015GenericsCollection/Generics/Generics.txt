Обобщения (Generics)

Обобщения или generics (обобщенные типы и методы) позволяют нам уйти от жесткого определения используемых типов.

Допустим, мы определяем класс для представления банковского счета. К примеру, он мог бы выглядеть следующим образом:

class Account{

    private int id;
    private int sum;

    Account(int id, int sum){
        this.id = id;
        this.sum = sum;
    }

    public int getId() { return id; }
    public int getSum() { return sum; }
    public void setSum(int sum) { this.sum = sum; }
}

Класс Account имеет два поля: id - уникальный идентификатор счета и sum - сумма на счете.

Нередко для идентификатора используются и строковые значения.
И числовые, и строковые значения имеют свои плюсы и минусы.
И на момент написания класса мы можем точно не знать, что лучше выбрать
для хранения идентификатора - строки или числа.
Либо, возможно, этот класс будет использоваться другими разработчиками,
которые могут иметь свое мнение по данной проблеме.
Например, в качестве типа id они захотят использовать какой-то свой класс.

Однако в процессе разработки мы можем не знать, какой именно тип представляет значение в id,
и при попытке получить число в данном случае мы столкнемся с исключением java.lang.ClassCastException.

Писать для каждого отдельного типа свою версию класса Account тоже не является хорошим решением,
так как в этом случае мы вынуждены повторяться.

Эти проблемы были призваны устранить обобщения или generics. Обобщения позволяют не указывать конкретный тип,
который будет использоваться. Поэтому определим класс Account как обобщенный:

//Generics.java
С помощью буквы T в определении класса class Account<T> мы указываем,
что данный тип T будет использоваться этим классом.
Параметр T в угловых скобках называется универсальным параметром,
так как вместо него можно подставить любой тип. При этом пока мы не знаем,
какой именно это будет тип: String, int или какой-то другой. Причем буква T выбрана условно,
это может и любая другая буква или набор символов.

После объявления класса мы можем применить универсальный параметр T:
так далее в классе объявляется переменная этого типа, которой затем присваивается значение в конструкторе.

Метод getId() возвращает значение переменной id, но так как данная переменная представляет тип T,
то данный метод также возвращает объект типа T: public T getId().

**************************************
Program.java

В данном случае тип String будет передаваться на место параметра T, а тип Double - на место параметра S.











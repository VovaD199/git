lambda-выражение

Java изначально полностью объектно-ориентированный язык. За исключением примитивных типов,
все в Java – это объекты. Даже массивы являются объектами. Экземпляры каждого класса – объекты.
Не существует ни единой возможности определить отдельно (вне класса – прим. перев.)
какую-нибудь функцию. И нет никакой возможности передать метод как аргумент или вернуть
тело метода как результат другого метода. Все так. Но так было до Java 8.

Зачем яве Lambda-выражения?


Lambda-выражения привносят в Java функциональное звено, которого так давно не хватало.
Lambda-выражения вносят в язык функциональность на ровне с объектами. Хотя это и не на 100% верно.
Lambda-выражения не являясь замыканиями предоставляют схожие возможности.                               //"Какой принцип ООП обычно реализуется с помощью замыканий" - ответ: инкапсуляция.
В Java, lambda-выражения – представляются объектами, и должны быть связаны с конкретным объектным типом,
который называется функциональный интерфейс.

Lambda-выражения – это анонимные функции (может и не 100% верное определение для Java,
но зато привносит некоторую ясность). Проще говоря, это метод без объявления, т.е.
без модификаторов доступа, возвращающие значение и имя.

(!!!) Они позволяют написать метод и сразу же использовать его.
(!!!) Особенно полезно в случае однократного вызова метода, т.к.
сокращает время на объявление и написание метода без необходимости создавать класс.

Lambda-выражения в Java обычно имеют следующий синтаксис (аргументы) -> (тело). Например:

(арг1, арг2...) -> { тело }
(тип1 арг1, тип2 арг2...) -> { тело }

Несколько примеров настоящих Lambda-выражений:

(int a, int b) -> {  return a + b; }
() -> System.out.println("Hello World");
(String s) -> { System.out.println(s); }
() -> 42
() -> { return 3.1415 };

(Functional Interface) – это интерфейсы только с одним абстрактным методом, объявленным в нем(lambda.java).
@FunctionalInterface
public interface WorkerInterface {
    public void doSomeWork();

===Структура Lambda-выражений===

    Lambda-выражения могут иметь от 0 и более входных параметров.

    Тип параметров можно указывать явно либо может быть получен из контекста.
    Например (int a) можно записать и так (a)

    Параметры заключаются в круглые скобки и разделяются запятыми. Например (a, b) или (int a, int b) или
    (String a, int b, float c)

    Если параметров нет, то нужно использовать пустые круглые скобки. Например () -> 42

    Когда параметр один, если тип не указывается явно, скобки можно опустить. Пример: a -> return a*a

    Тело Lambda-выражения может содержать от 0 и более выражений.

    Если тело состоит из одного оператора, его можно не заключать в фигурные скобки,
    а возвращаемое значение можно указывать без ключевого слова return.

    В противном случае фигурные скобки обязательны (блок кода),
    а в конце надо указывать возвращаемое значение с использованием
    ключевого слова return (в противном случае типом возвращаемого значения будет void).

///////////

///////////
lambda2
// Старый способ:
List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7);

for(Integer n: list) {
    System.out.println(n);
}

// Новый способ:
List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7);
list.forEach(n -> System.out.println(n));

// Новый способ с использованием оператора двойного двоеточия (::),
который в Java 8 конвертирует обычный метод в lambda-выражение:
list.forEach(System.out::println);

Начиная с JDK 8 в Java можно в качестве параметра в метод передавать ссылку на другой метод.
В принципе данный способ аналогичен передаче в метод лямбда-выражения.

Ссылка на метод передается в виде имя_класса::имя_статического_метода (если метод статический)
или объект_класса::имя_метода (если метод нестатический).

Ссылки на конструкторы
Подобным образом мы можем использовать конструкторы: название_класса::new.
///
функциональный интерфейс Predicate1.java
///

Чтобы преобразовать обычный список в поток. Java 8 предоставляет шикарный класс Stream.
StreamDemo
/*
Мы передаем lambda-выражение x -> x*x в метод map(), который применяет его ко всем элементам в потоке.
После чего мы используем forEach для печати всех элементов списка.
 */

StreamDemo2
/*
В этом примере применен метод свертки (редукции) reduce(). М
ы используем метод map() для возведения в квадрат каждого элемента,
а потом применяем метод reduce() для свертки всех элементов в одно число.
 */

///////////////////////
===Отличие Lambda-выражений от анонимных класов===
Главное отличие состоит в использовании ключевого слова this.
Для анонимных классов ключевое слово ‘this’ обозначает объект анонимного класса,
в то время как в lambda-выражении ‘this’ обозначает объект класса, в котором lambda-выражение используется.

Другое их отличие заключается в способе компиляции.
Java компилирует lambda-выражения с преобразованием их в private-методы класса.
При этом используется инструкция invokedynamic, появившаяся в Java 7 для динамической привязки метода.
Тал Вайс (Tal Weiss) описал в своем блоге как Java компилирует lambda-выражения в байт-код.

===Заключение===
Марк Рейнхолд (Mark Reinhold - Oracle’s Chief Architect), назвал Lambda-выражения
самым значительным изменением в модели программирования,
которое когда-либо происходило — даже более значительным, чем дженерики (generics).
Должно быть он прав, т.к. они дают Java программистам возможности
функциональных языков программирования, которых так давно все ждали.
Наряду с такими новшествами как методы виртуального расширения (Virtual extension methods),
Lambda-выражения позволяют писать очень качественный код.



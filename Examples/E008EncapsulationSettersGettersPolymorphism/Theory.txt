package Examples.E008EncapsulationSettersGettersPolymorphism;

public class EncapsulationSettersAndGetters {
    public static void main(String[] args) {
        Person person1 = new Person();
        person1.name = "";
        person1.age = 5;
        person1.speak();
    }
}

class Person{
    String name;
    int age;

    void speak(){
       System.out.println("Меня зовут "+ name +",мне"+age+" ,лет");
    }
}
=====================
person1.age = 5;
это доступ к полям класса через объект

пример  использования API, мы можем менять внутри класса Прсона и ничего не сломается

name - userName (если менять имена аргументов внутри классов это не должно негативно сказываться на работе всего приложения)
Если обращаться к полям класс через методы, то можно проверить корректность введенных
данных. isInteger, isString, isEmpty
=====================
Сеттеры и Геттеры
Соответственно, name and age должны быть ПРИВАТНЫМИ
значить строки 6 и 7 становятся не актуальными, наш пользователь будет теперь получать доступ
через Сеттеры и Геттеры
***********Сеттер (без указателя this) *************************************
    public void setName(String userName){
        name = userName;
    }
************************************************
теперь строки 6 и 7
будут выглядеть так:
person1.setName("")

 В main теперь можно написать так:
 System.out.println("Выводим значение в main методе"+person1.getName(););
************Сеттер (только для примера, логика в сеттере не должна находиться) ************************************
    public void setName(String userName){
        if (userName.isEmpty()){
            System.out.println("Вы ввели пустое имя");
        }else {
        name = userName;}
    }
************************************************
if (userAge<0) вместе написать сеттер на занятии
************************************************

********* ключевое слово this в сеттерах ***************************************
========= Пример 1 для объяснения ============
    public void setName(String userName){
        name = userName;
    }
========= Пример 2 для объяснения ============
scope(Область видимости) только внутри фигурных скобок
 можно ли сделать так:
     public void setName(String name){
         name = name;
     }
нонсенс - Джава возьмет две ближайшие переменные !!!
И вот что бы такого избежать есть слово - this

И выглядеть Сеттер должен теперь так:
======== Правильный пример !!! =========
     public void setName(String name){
         this.name = name;
     }
this - указывает на переменную класса
this - вызывает объект внутри класса (person1.name), тот объетк, который его вызвал
 или который поступил в параметрах метода

вместе создадим person2 для проверки написанного выше
************************************************
Актуализировать конструктор
1) конструктор по умолчанию, всегда ли он виден
2) конструктор с параметрами
3) когда пропадает конструктор по умолчанию? что делать если он все-равно нужен?
4) что такое перегруженный конструктор. для чего слово this
************************************************
static

Переменные name and age? не принадлежат классу, они называются "переменные класса",
но принадлежат они объектам класса(person1.name).
Потому что у класса не может быть имени, а у объекта может. Пример.

Если в классе Human, объявить:
public static String description;
то в методе main можно

Human.description = "Nice";
что будет означать, что Описание принадлежит классу!!!

Human.getDescription();

public static void getDescription(){
    System.out.println(description);
}
Инициализация и вызов метода работает!
А вот обратиться через объект класса не получится, потому что это не имеет смысла

************************************************
Age и Name создается для каждого объекта класса,
а description - создается всего один раз для класса

нет смысла обращаться в статическом методе к переменным класса.
при запуске программы статические переменные и методы уже будут существовать,
а переменные класса в начале программы (при инициализации объектов класса).

//библиотека Math.pow(2.4) - вызывается класс Мат и его метод без создание объектов
================== просто пример ===========================
в конструкторе счетчик count++
printNamberOfPeople()  - метод sout(count)
а в main - h1.printNamberOfPeople();
********************************************
Полиморфизм - способность методов обрабатывать переменные разных типов

======== Пример, которй нужно показывать на занятии в примерах ======
Три класса: Анимал базовый класс, Дог-класс наследник и Кот-класс наследник.

У Анимал есть метод "Есть".
Дог наследуется от Анимал и имеет свой метод "Есть" (переопределяя его, с указанием - Дог кушает).
Дог имеет свой метод "Барк".
Кот наследуется от Анимал и не имеет своего метода "Есть".

Если наследовались правильно, то у класса Дог будет доступ к методу "Есть"

Есть еще класс Тест, который демонстрирует доступность
класса "Кот" к методу "Есть", но недоступность к методу Барк(гавкать).

Позднее связывание!!!
При попытке вызвать метод "Есть" из класса-наследника "Кот", Джава понимает, что у него нет этого метода, тогда она смотрит на родителя
и если метод "Есть" есть у родителя, то программа выполняет этот метод.
==========================

В этом прелесть Полиморфизма!
Практическая польза Полиморфизма -
Код можно сделать меньше, а во вторых многоразовым (переиспользовать его).
